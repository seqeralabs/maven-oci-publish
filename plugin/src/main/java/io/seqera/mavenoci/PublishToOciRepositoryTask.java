/*
 * Copyright 2025, Seqera Labs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.seqera.mavenoci;

import java.util.List;
import java.util.stream.Collectors;

import land.oras.Annotations;
import land.oras.ArtifactType;
import land.oras.ContainerRef;
import land.oras.LocalPath;
import land.oras.Manifest;
import land.oras.Registry;
import org.gradle.api.DefaultTask;
import org.gradle.api.GradleException;
import org.gradle.api.file.ConfigurableFileCollection;
import org.gradle.api.logging.Logger;
import org.gradle.api.logging.Logging;
import org.gradle.api.provider.Property;
import org.gradle.api.tasks.Input;
import org.gradle.api.tasks.InputFiles;
import org.gradle.api.tasks.Internal;
import org.gradle.api.tasks.Optional;
import org.gradle.api.tasks.TaskAction;
import org.gradle.api.tasks.UntrackedTask;

/**
 * Gradle task for publishing Maven artifacts to OCI registries using the ORAS protocol.
 * 
 * <p>This task handles the complete publishing workflow from Maven artifacts to OCI registry storage:</p>
 * <ul>
 *   <li>Collects artifacts from Gradle's software components (JARs, POMs, sources, javadoc)</li>
 *   <li>Maps Maven coordinates to OCI references using coordinate sanitization</li>
 *   <li>Authenticates with the target OCI registry using provided credentials</li>
 *   <li>Publishes artifacts as OCI artifacts with appropriate media types</li>
 *   <li>Creates proper OCI manifest linking all related artifacts</li>
 * </ul>
 * 
 * <h2>Task Inputs</h2>
 * <p>The task is configured with the following inputs:</p>
 * <ul>
 *   <li><strong>Registry URL</strong>: Target OCI registry endpoint</li>
 *   <li><strong>Credentials</strong>: Username/password for registry authentication</li>
 *   <li><strong>Maven Coordinates</strong>: GroupId, artifactId, version for coordinate mapping</li>
 *   <li><strong>Artifacts</strong>: Collection of files to publish (JAR, POM, sources, javadoc)</li>
 *   <li><strong>Namespace</strong>: Optional namespace within the registry</li>
 * </ul>
 * 
 * <h2>OCI Artifact Structure</h2>
 * <p>Published artifacts maintain their Maven identity while being stored as OCI artifacts:</p>
 * <pre>
 * OCI Reference: registry.com/[namespace/]sanitized-groupId/artifactId:version
 * Manifest: Links all related artifacts (JAR, POM, sources, javadoc)
 * Media Types: application/java-archive, application/xml, etc.
 * </pre>
 * 
 * <h2>Generated Tasks</h2>
 * <p>This task is automatically generated by the plugin for each publication-repository combination:</p>
 * <ul>
 *   <li>{@code publish<Publication>To<Repository>Repository}</li>
 *   <li>Example: {@code publishMavenPublicationToDockerHubRepository}</li>
 * </ul>
 * 
 * <h2>Configuration Cache Compatibility</h2>
 * <p><strong>Note:</strong> This task is not compatible with Gradle's configuration cache due to
 * the complex nature of Maven publication objects. Use {@code --no-configuration-cache}
 * when running publishing tasks.</p>
 * 
 * @see MavenOciArtifactRepository
 * @see MavenOciRepository
 * @since 1.0
 */
@UntrackedTask(because = "Not compatible with configuration cache due to Maven publication objects")
public abstract class PublishToOciRepositoryTask extends DefaultTask {
    
    private static final Logger logger = Logging.getLogger(PublishToOciRepositoryTask.class);
    
    @Input
    public abstract Property<String> getRegistryUrl();
    
    @Input
    @Optional
    public abstract Property<String> getRepository();
    
    @Input
    @Optional
    public abstract Property<String> getTag();
    
    @Input
    @Optional
    public abstract Property<String> getGroupId();
    
    @Input
    @Optional
    public abstract Property<String> getArtifactId();
    
    @Input
    @Optional
    public abstract Property<String> getVersion();
    
    @Input
    @Optional
    public abstract Property<String> getUsername();
    
    @Input
    @Optional
    public abstract Property<String> getPassword();
    
    @Input
    @Optional
    public abstract Property<String> getNamespace();
    
    @Input
    public abstract Property<Boolean> getInsecure();
    
    @InputFiles
    public abstract ConfigurableFileCollection getArtifacts();
    
    @Internal
    public abstract Property<String> getPublicationName();
    
    @Internal
    public abstract Property<String> getRepositoryName();
    
    @Input
    @Optional
    public abstract Property<String> getExecutionId();
    
    @Input
    public abstract Property<OverwritePolicy> getOverwritePolicy();
    
    public PublishToOciRepositoryTask() {
        setDescription("Publishes Maven artifacts to an OCI registry");
        setGroup("publishing");
        
        // Set defaults
        getInsecure().convention(false);
        getExecutionId().convention("default-execution");
        getOverwritePolicy().convention(OverwritePolicy.FAIL);
    }
    
    @TaskAction
    public void publishToOciRegistry() {
        // Always execute this task - force execution with lifecycle logging
        logger.lifecycle("=== Maven OCI Publish Task Executing ===");
        logger.info("Publishing to OCI registry: {}", getRegistryUrl().get());
        
        // Debug logging for task configuration
        logger.info("Task configuration:");
        logger.info("  Registry URL: {}", getRegistryUrl().getOrElse("not set"));
        logger.info("  Group ID: {}", getGroupId().getOrElse("not set"));
        logger.info("  Artifact ID: {}", getArtifactId().getOrElse("not set"));
        logger.info("  Version: {}", getVersion().getOrElse("not set"));
        logger.info("  Repository: {}", getRepository().getOrElse("not set"));
        logger.info("  Tag: {}", getTag().getOrElse("not set"));
        logger.info("  Namespace: {}", getNamespace().getOrElse("not set"));
        logger.info("  Username: {}", getUsername().getOrElse("not set"));
        logger.info("  Has password: {}", getPassword().isPresent());
        logger.info("  Insecure mode: {}", getInsecure().getOrElse(false));
        logger.info("  Artifact files: {}", getArtifacts().getFiles());
        
        try {
            // Check for artifacts first, before creating registry client
            if (getArtifacts().getFiles().isEmpty()) {
                logger.warn("No artifacts to publish - check that Maven publication is configured correctly");
                logger.info("Task executed successfully with no artifacts");
                return;
            }
            
            // Also check if artifacts are effectively empty (zero-byte files)
            boolean hasValidArtifacts = getArtifacts().getFiles().stream()
                .anyMatch(file -> file.exists() && file.length() > 0);
            
            if (!hasValidArtifacts) {
                logger.warn("No artifacts to publish - all artifact files are empty or non-existent");
                logger.info("Task executed successfully with no artifacts");
                return;
            }
            
            // Create registry client only if we have valid artifacts
            Registry registry = createRegistry();
            
            // Convert artifacts to LocalPath objects
            List<LocalPath> artifactPaths = getArtifacts().getFiles().stream()
                .map(file -> {
                    // Determine media type based on file extension
                    String mediaType = determineMediaType(file.getName());
                    logger.debug("Adding artifact: {} with media type: {}", file.getName(), mediaType);
                    return LocalPath.of(file.toPath(), mediaType);
                })
                .collect(Collectors.toList());
            
            if (artifactPaths.isEmpty()) {
                logger.warn("No artifacts to publish after processing - files may not be accessible");
                logger.info("Task executed successfully with no accessible artifacts");
                return;
            }
            
            // Build OCI reference using new coordinate mapping
            String containerRef = buildOciReference();
            logger.info("Built OCI reference: {}", containerRef);
            
            ContainerRef ref = ContainerRef.parse(containerRef);
            
            logger.info("Publishing {} artifacts to {}", artifactPaths.size(), containerRef);
            logger.info("Maven coordinates: {}:{}:{}", getGroupId().getOrElse("unknown"), 
                       getArtifactId().getOrElse("unknown"), getVersion().getOrElse("unknown"));
            logger.info("ContainerRef parsed - registry: {}, repository: {}, tag: {}", 
                       ref.getRegistry(), ref.getRepository(), ref.getTag());
            
            // Check overwrite policy before pushing
            OverwritePolicy policy = getOverwritePolicy().getOrElse(OverwritePolicy.FAIL);
            logger.info("Using overwrite policy: {} ({})", policy, policy.getDescription());
            
            if (policy != OverwritePolicy.OVERRIDE) {
                boolean packageExists = checkPackageExists(registry, ref);
                if (packageExists) {
                    handleExistingPackage(policy, containerRef);
                    return;
                }
            }
            
            // Push artifacts to registry using varargs
            Manifest manifest = registry.pushArtifact(
                ref,
                ArtifactType.from("application/vnd.oci.image.manifest.v1+json"),
                Annotations.empty(),
                null,
                artifactPaths.toArray(new LocalPath[0])
            );
            
            logger.info("Successfully published artifacts. Schema version: {}", manifest.getSchemaVersion());
            
        } catch (Exception e) {
            logger.error("Failed to publish to OCI registry: {}", getRegistryUrl().get(), e);
            throw new GradleException("Failed to publish to OCI registry " + getRegistryUrl().get() + ": " + e.getMessage(), e);
        }
    }
    
    private String buildOciReference() {
        // Check if we have Maven coordinates for new mapping
        if (getGroupId().isPresent() && getArtifactId().isPresent() && getVersion().isPresent()) {
            // Use namespace-aware approach if namespace is provided
            if (getNamespace().isPresent()) {
                return buildOciReferenceWithNamespace(getGroupId().get(), getArtifactId().get(), getVersion().get());
            } else {
                // Use URL parsing approach
                MavenOciRegistryUriParser.OciRegistryInfo registryInfo = MavenOciRegistryUriParser.parse(getRegistryUrl().get());
                return registryInfo.buildOciReference(getGroupId().get(), getArtifactId().get(), getVersion().get());
            }
        } else if (getRepository().isPresent() && getTag().isPresent()) {
            // Fall back to legacy format for backward compatibility
            logger.warn("Using legacy repository format. Consider updating to use Maven coordinates.");
            return getRepository().get() + ":" + getTag().get();
        } else {
            throw new GradleException("Either Maven coordinates (groupId, artifactId, version) or legacy repository/tag must be specified");
        }
    }
    
    /**
     * Builds an OCI reference using the separate namespace property.
     * This is Harbor-compatible approach that avoids URL parsing issues.
     */
    private String buildOciReferenceWithNamespace(String groupId, String artifactId, String version) {
        StringBuilder ref = new StringBuilder();
        
        // Add registry host (without protocol)
        String registryUrl = getRegistryUrl().get();
        String host = registryUrl.replaceFirst("^https?://", "");
        logger.info("Registry host: {}", host);
        ref.append(host);
        
        // Add namespace
        if (getNamespace().isPresent()) {
            logger.info("Adding namespace: {}", getNamespace().get());
            ref.append("/").append(getNamespace().get());
        } else {
            logger.info("No namespace provided");
        }
        
        // Add sanitized group
        String sanitizedGroup = MavenOciGroupSanitizer.sanitize(groupId);
        logger.info("Sanitized group: {}", sanitizedGroup);
        ref.append("/").append(sanitizedGroup);
        
        // Add artifact and version
        logger.info("Artifact: {}, Version: {}", artifactId, version);
        ref.append("/").append(artifactId).append(":").append(version);
        
        String result = ref.toString();
        logger.info("Built OCI reference with namespace: {}", result);
        return result;
    }
    
    private String determineMediaType(String filename) {
        int lastDotIndex = filename.lastIndexOf('.');
        if (lastDotIndex == -1) {
            return "application/octet-stream";
        }
        
        String extension = filename.substring(lastDotIndex + 1).toLowerCase();
        switch (extension) {
            case "jar":
                return "application/java-archive";
            case "pom":
            case "xml":
                return "application/xml";
            case "json":
                return "application/json";
            case "tar":
            case "tgz":
                return "application/gzip";
            default:
                if (filename.endsWith(".tar.gz")) {
                    return "application/gzip";
                }
                return "application/octet-stream";
        }
    }
    
    private Registry createRegistry() {
        Registry.Builder builder = Registry.builder();
        
        // Extract hostname from registry URL for Harbor compatibility
        String registryHost = extractRegistryHost(getRegistryUrl().get());
        
        // Configure credentials and security
        if (getInsecure().get()) {
            // Use insecure mode for development
            if (getUsername().isPresent() && getPassword().isPresent()) {
                logger.info("Using insecure mode with explicit credentials for Harbor registry");
                // Use hostname instead of full URL for Harbor compatibility
                builder.insecure(registryHost, getUsername().get(), getPassword().get());
            } else {
                logger.info("Using insecure mode with anonymous access");
                builder.insecure();
            }
        } else {
            // Use secure mode with Harbor-specific authentication handling
            if (getUsername().isPresent() && getPassword().isPresent()) {
                logger.info("Using secure mode with explicit credentials for Harbor registry");
                // Try Harbor-specific authentication by using registry host without protocol
                try {
                    builder.defaults(getUsername().get(), getPassword().get());
                } catch (Exception e) {
                    logger.warn("Failed to configure default credentials, trying with specific host: {}", registryHost);
                    // Fallback: try with specific host configuration
                    builder.defaults(getUsername().get(), getPassword().get());
                }
            } else {
                logger.info("Using secure mode with anonymous access (or default credentials from ~/.docker/config.json)");
                builder.defaults();
            }
        }
        
        return builder.build();
    }
    
    /**
     * Extracts the registry hostname from a full registry URL.
     * Harbor registries often need just the hostname for authentication.
     */
    private String extractRegistryHost(String registryUrl) {
        try {
            if (registryUrl.contains("://")) {
                // Parse as URL
                java.net.URI uri = java.net.URI.create(registryUrl);
                String host = uri.getHost();
                int port = uri.getPort();
                if (port != -1 && port != 80 && port != 443) {
                    return host + ":" + port;
                }
                return host;
            } else {
                // Already just hostname
                return registryUrl;
            }
        } catch (Exception e) {
            logger.warn("Failed to extract registry host from URL: {}, using original URL", registryUrl);
            return registryUrl;
        }
    }
    
    /**
     * Checks if a package already exists in the OCI registry.
     * 
     * @param registry the OCI registry client
     * @param ref the container reference to check
     * @return true if the package exists, false otherwise
     */
    private boolean checkPackageExists(Registry registry, ContainerRef ref) {
        try {
            logger.debug("Checking if package exists: {}", ref);
            // Attempt to get the manifest - if it exists, the package exists
            Manifest existingManifest = registry.getManifest(ref);
            logger.debug("Package exists with manifest: {}", existingManifest.getSchemaVersion());
            return true;
        } catch (Exception e) {
            // If we get any exception (404, 401, etc.), assume package doesn't exist
            logger.debug("Package does not exist or is not accessible from OCI registry {}: {}", getRegistryUrl().get(), e.getMessage());
            return false;
        }
    }
    
    /**
     * Handles the case when a package already exists according to the configured policy.
     * 
     * @param policy the overwrite policy to apply
     * @param containerRef the OCI reference that exists
     */
    private void handleExistingPackage(OverwritePolicy policy, String containerRef) {
        switch (policy) {
            case FAIL:
                String errorMsg = String.format(
                    "Package already exists in registry: %s. " +
                    "Use overwritePolicy = 'override' to replace it, " +
                    "or overwritePolicy = 'skip' to skip publishing.",
                    containerRef
                );
                logger.error(errorMsg);
                throw new GradleException(errorMsg);
                
            case SKIP:
                logger.lifecycle("Package already exists, skipping publication: {}", containerRef);
                logger.info("Task completed successfully (package skipped due to overwrite policy)");
                break;
                
            case OVERRIDE:
                // This case should never be reached since we skip the check for OVERRIDE policy
                logger.warn("Package already exists, but will be overridden: {}", containerRef);
                break;
                
            default:
                throw new IllegalStateException("Unexpected overwrite policy: " + policy);
        }
    }
}
